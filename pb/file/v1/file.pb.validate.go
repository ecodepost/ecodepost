// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: file/v1/file.proto

package filev1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	commonv1 "ecodepost/pb/common/v1"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = commonv1.CMN_FILE_SORT(0)
)

// Validate checks the field values on ListPageReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListPageReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListPageReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListPageReqMultiError, or
// nil if none found.
func (m *ListPageReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListPageReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	// no validation rules for SpaceGuid

	if all {
		switch v := interface{}(m.GetPagination()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListPageReqValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListPageReqValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPagination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListPageReqValidationError{
				field:  "Pagination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Sort

	if len(errors) > 0 {
		return ListPageReqMultiError(errors)
	}

	return nil
}

// ListPageReqMultiError is an error wrapping multiple validation errors
// returned by ListPageReq.ValidateAll() if the designated constraints aren't met.
type ListPageReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListPageReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListPageReqMultiError) AllErrors() []error { return m }

// ListPageReqValidationError is the validation error returned by
// ListPageReq.Validate if the designated constraints aren't met.
type ListPageReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListPageReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListPageReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListPageReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListPageReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListPageReqValidationError) ErrorName() string { return "ListPageReqValidationError" }

// Error satisfies the builtin error interface
func (e ListPageReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListPageReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListPageReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListPageReqValidationError{}

// Validate checks the field values on ListPageRes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListPageRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListPageRes with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListPageResMultiError, or
// nil if none found.
func (m *ListPageRes) ValidateAll() error {
	return m.validate(true)
}

func (m *ListPageRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListPageResValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListPageResValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListPageResValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetPagination()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListPageResValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListPageResValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPagination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListPageResValidationError{
				field:  "Pagination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListPageResMultiError(errors)
	}

	return nil
}

// ListPageResMultiError is an error wrapping multiple validation errors
// returned by ListPageRes.ValidateAll() if the designated constraints aren't met.
type ListPageResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListPageResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListPageResMultiError) AllErrors() []error { return m }

// ListPageResValidationError is the validation error returned by
// ListPageRes.Validate if the designated constraints aren't met.
type ListPageResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListPageResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListPageResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListPageResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListPageResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListPageResValidationError) ErrorName() string { return "ListPageResValidationError" }

// Error satisfies the builtin error interface
func (e ListPageResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListPageRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListPageResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListPageResValidationError{}

// Validate checks the field values on RecommendListReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RecommendListReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RecommendListReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RecommendListReqMultiError, or nil if none found.
func (m *RecommendListReq) ValidateAll() error {
	return m.validate(true)
}

func (m *RecommendListReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	// no validation rules for SpaceGuid

	if len(errors) > 0 {
		return RecommendListReqMultiError(errors)
	}

	return nil
}

// RecommendListReqMultiError is an error wrapping multiple validation errors
// returned by RecommendListReq.ValidateAll() if the designated constraints
// aren't met.
type RecommendListReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RecommendListReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RecommendListReqMultiError) AllErrors() []error { return m }

// RecommendListReqValidationError is the validation error returned by
// RecommendListReq.Validate if the designated constraints aren't met.
type RecommendListReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RecommendListReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RecommendListReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RecommendListReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RecommendListReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RecommendListReqValidationError) ErrorName() string { return "RecommendListReqValidationError" }

// Error satisfies the builtin error interface
func (e RecommendListReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRecommendListReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RecommendListReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RecommendListReqValidationError{}

// Validate checks the field values on RecommendListRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RecommendListRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RecommendListRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RecommendListResMultiError, or nil if none found.
func (m *RecommendListRes) ValidateAll() error {
	return m.validate(true)
}

func (m *RecommendListRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RecommendListResValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RecommendListResValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RecommendListResValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetPagination()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RecommendListResValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RecommendListResValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPagination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RecommendListResValidationError{
				field:  "Pagination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RecommendListResMultiError(errors)
	}

	return nil
}

// RecommendListResMultiError is an error wrapping multiple validation errors
// returned by RecommendListRes.ValidateAll() if the designated constraints
// aren't met.
type RecommendListResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RecommendListResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RecommendListResMultiError) AllErrors() []error { return m }

// RecommendListResValidationError is the validation error returned by
// RecommendListRes.Validate if the designated constraints aren't met.
type RecommendListResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RecommendListResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RecommendListResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RecommendListResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RecommendListResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RecommendListResValidationError) ErrorName() string { return "RecommendListResValidationError" }

// Error satisfies the builtin error interface
func (e RecommendListResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRecommendListRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RecommendListResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RecommendListResValidationError{}

// Validate checks the field values on SpaceTopListReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SpaceTopListReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SpaceTopListReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SpaceTopListReqMultiError, or nil if none found.
func (m *SpaceTopListReq) ValidateAll() error {
	return m.validate(true)
}

func (m *SpaceTopListReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	// no validation rules for SpaceGuid

	if len(errors) > 0 {
		return SpaceTopListReqMultiError(errors)
	}

	return nil
}

// SpaceTopListReqMultiError is an error wrapping multiple validation errors
// returned by SpaceTopListReq.ValidateAll() if the designated constraints
// aren't met.
type SpaceTopListReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SpaceTopListReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SpaceTopListReqMultiError) AllErrors() []error { return m }

// SpaceTopListReqValidationError is the validation error returned by
// SpaceTopListReq.Validate if the designated constraints aren't met.
type SpaceTopListReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SpaceTopListReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SpaceTopListReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SpaceTopListReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SpaceTopListReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SpaceTopListReqValidationError) ErrorName() string { return "SpaceTopListReqValidationError" }

// Error satisfies the builtin error interface
func (e SpaceTopListReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSpaceTopListReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SpaceTopListReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SpaceTopListReqValidationError{}

// Validate checks the field values on SpaceTopListRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SpaceTopListRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SpaceTopListRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SpaceTopListResMultiError, or nil if none found.
func (m *SpaceTopListRes) ValidateAll() error {
	return m.validate(true)
}

func (m *SpaceTopListRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SpaceTopListResValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SpaceTopListResValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SpaceTopListResValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetPagination()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SpaceTopListResValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SpaceTopListResValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPagination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SpaceTopListResValidationError{
				field:  "Pagination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SpaceTopListResMultiError(errors)
	}

	return nil
}

// SpaceTopListResMultiError is an error wrapping multiple validation errors
// returned by SpaceTopListRes.ValidateAll() if the designated constraints
// aren't met.
type SpaceTopListResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SpaceTopListResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SpaceTopListResMultiError) AllErrors() []error { return m }

// SpaceTopListResValidationError is the validation error returned by
// SpaceTopListRes.Validate if the designated constraints aren't met.
type SpaceTopListResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SpaceTopListResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SpaceTopListResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SpaceTopListResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SpaceTopListResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SpaceTopListResValidationError) ErrorName() string { return "SpaceTopListResValidationError" }

// Error satisfies the builtin error interface
func (e SpaceTopListResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSpaceTopListRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SpaceTopListResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SpaceTopListResValidationError{}

// Validate checks the field values on GetShowInfoReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetShowInfoReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetShowInfoReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetShowInfoReqMultiError,
// or nil if none found.
func (m *GetShowInfoReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetShowInfoReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	// no validation rules for Guid

	if len(errors) > 0 {
		return GetShowInfoReqMultiError(errors)
	}

	return nil
}

// GetShowInfoReqMultiError is an error wrapping multiple validation errors
// returned by GetShowInfoReq.ValidateAll() if the designated constraints
// aren't met.
type GetShowInfoReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetShowInfoReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetShowInfoReqMultiError) AllErrors() []error { return m }

// GetShowInfoReqValidationError is the validation error returned by
// GetShowInfoReq.Validate if the designated constraints aren't met.
type GetShowInfoReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetShowInfoReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetShowInfoReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetShowInfoReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetShowInfoReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetShowInfoReqValidationError) ErrorName() string { return "GetShowInfoReqValidationError" }

// Error satisfies the builtin error interface
func (e GetShowInfoReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetShowInfoReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetShowInfoReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetShowInfoReqValidationError{}

// Validate checks the field values on GetShowInfoRes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetShowInfoRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetShowInfoRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetShowInfoResMultiError,
// or nil if none found.
func (m *GetShowInfoRes) ValidateAll() error {
	return m.validate(true)
}

func (m *GetShowInfoRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFile()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetShowInfoResValidationError{
					field:  "File",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetShowInfoResValidationError{
					field:  "File",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFile()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetShowInfoResValidationError{
				field:  "File",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetShowInfoResMultiError(errors)
	}

	return nil
}

// GetShowInfoResMultiError is an error wrapping multiple validation errors
// returned by GetShowInfoRes.ValidateAll() if the designated constraints
// aren't met.
type GetShowInfoResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetShowInfoResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetShowInfoResMultiError) AllErrors() []error { return m }

// GetShowInfoResValidationError is the validation error returned by
// GetShowInfoRes.Validate if the designated constraints aren't met.
type GetShowInfoResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetShowInfoResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetShowInfoResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetShowInfoResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetShowInfoResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetShowInfoResValidationError) ErrorName() string { return "GetShowInfoResValidationError" }

// Error satisfies the builtin error interface
func (e GetShowInfoResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetShowInfoRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetShowInfoResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetShowInfoResValidationError{}

// Validate checks the field values on EmojiListReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EmojiListReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EmojiListReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EmojiListReqMultiError, or
// nil if none found.
func (m *EmojiListReq) ValidateAll() error {
	return m.validate(true)
}

func (m *EmojiListReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	// no validation rules for SpaceGuid

	if len(errors) > 0 {
		return EmojiListReqMultiError(errors)
	}

	return nil
}

// EmojiListReqMultiError is an error wrapping multiple validation errors
// returned by EmojiListReq.ValidateAll() if the designated constraints aren't met.
type EmojiListReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EmojiListReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EmojiListReqMultiError) AllErrors() []error { return m }

// EmojiListReqValidationError is the validation error returned by
// EmojiListReq.Validate if the designated constraints aren't met.
type EmojiListReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmojiListReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmojiListReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmojiListReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmojiListReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmojiListReqValidationError) ErrorName() string { return "EmojiListReqValidationError" }

// Error satisfies the builtin error interface
func (e EmojiListReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmojiListReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmojiListReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmojiListReqValidationError{}

// Validate checks the field values on EmojiListRes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EmojiListRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EmojiListRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EmojiListResMultiError, or
// nil if none found.
func (m *EmojiListRes) ValidateAll() error {
	return m.validate(true)
}

func (m *EmojiListRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EmojiListResValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EmojiListResValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EmojiListResValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return EmojiListResMultiError(errors)
	}

	return nil
}

// EmojiListResMultiError is an error wrapping multiple validation errors
// returned by EmojiListRes.ValidateAll() if the designated constraints aren't met.
type EmojiListResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EmojiListResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EmojiListResMultiError) AllErrors() []error { return m }

// EmojiListResValidationError is the validation error returned by
// EmojiListRes.Validate if the designated constraints aren't met.
type EmojiListResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmojiListResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmojiListResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmojiListResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmojiListResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmojiListResValidationError) ErrorName() string { return "EmojiListResValidationError" }

// Error satisfies the builtin error interface
func (e EmojiListResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmojiListRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmojiListResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmojiListResValidationError{}

// Validate checks the field values on CreateEmojiReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateEmojiReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateEmojiReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreateEmojiReqMultiError,
// or nil if none found.
func (m *CreateEmojiReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateEmojiReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	// no validation rules for Guid

	// no validation rules for V

	if len(errors) > 0 {
		return CreateEmojiReqMultiError(errors)
	}

	return nil
}

// CreateEmojiReqMultiError is an error wrapping multiple validation errors
// returned by CreateEmojiReq.ValidateAll() if the designated constraints
// aren't met.
type CreateEmojiReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateEmojiReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateEmojiReqMultiError) AllErrors() []error { return m }

// CreateEmojiReqValidationError is the validation error returned by
// CreateEmojiReq.Validate if the designated constraints aren't met.
type CreateEmojiReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateEmojiReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateEmojiReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateEmojiReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateEmojiReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateEmojiReqValidationError) ErrorName() string { return "CreateEmojiReqValidationError" }

// Error satisfies the builtin error interface
func (e CreateEmojiReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateEmojiReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateEmojiReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateEmojiReqValidationError{}

// Validate checks the field values on CreateEmojiRes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateEmojiRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateEmojiRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreateEmojiResMultiError,
// or nil if none found.
func (m *CreateEmojiRes) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateEmojiRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return CreateEmojiResMultiError(errors)
	}

	return nil
}

// CreateEmojiResMultiError is an error wrapping multiple validation errors
// returned by CreateEmojiRes.ValidateAll() if the designated constraints
// aren't met.
type CreateEmojiResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateEmojiResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateEmojiResMultiError) AllErrors() []error { return m }

// CreateEmojiResValidationError is the validation error returned by
// CreateEmojiRes.Validate if the designated constraints aren't met.
type CreateEmojiResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateEmojiResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateEmojiResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateEmojiResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateEmojiResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateEmojiResValidationError) ErrorName() string { return "CreateEmojiResValidationError" }

// Error satisfies the builtin error interface
func (e CreateEmojiResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateEmojiRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateEmojiResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateEmojiResValidationError{}

// Validate checks the field values on DeleteEmojiReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeleteEmojiReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteEmojiReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeleteEmojiReqMultiError,
// or nil if none found.
func (m *DeleteEmojiReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteEmojiReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	// no validation rules for Guid

	// no validation rules for V

	if len(errors) > 0 {
		return DeleteEmojiReqMultiError(errors)
	}

	return nil
}

// DeleteEmojiReqMultiError is an error wrapping multiple validation errors
// returned by DeleteEmojiReq.ValidateAll() if the designated constraints
// aren't met.
type DeleteEmojiReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteEmojiReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteEmojiReqMultiError) AllErrors() []error { return m }

// DeleteEmojiReqValidationError is the validation error returned by
// DeleteEmojiReq.Validate if the designated constraints aren't met.
type DeleteEmojiReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteEmojiReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteEmojiReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteEmojiReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteEmojiReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteEmojiReqValidationError) ErrorName() string { return "DeleteEmojiReqValidationError" }

// Error satisfies the builtin error interface
func (e DeleteEmojiReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteEmojiReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteEmojiReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteEmojiReqValidationError{}

// Validate checks the field values on DeleteEmojiRes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeleteEmojiRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteEmojiRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeleteEmojiResMultiError,
// or nil if none found.
func (m *DeleteEmojiRes) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteEmojiRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteEmojiResMultiError(errors)
	}

	return nil
}

// DeleteEmojiResMultiError is an error wrapping multiple validation errors
// returned by DeleteEmojiRes.ValidateAll() if the designated constraints
// aren't met.
type DeleteEmojiResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteEmojiResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteEmojiResMultiError) AllErrors() []error { return m }

// DeleteEmojiResValidationError is the validation error returned by
// DeleteEmojiRes.Validate if the designated constraints aren't met.
type DeleteEmojiResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteEmojiResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteEmojiResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteEmojiResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteEmojiResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteEmojiResValidationError) ErrorName() string { return "DeleteEmojiResValidationError" }

// Error satisfies the builtin error interface
func (e DeleteEmojiResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteEmojiRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteEmojiResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteEmojiResValidationError{}

// Validate checks the field values on MyEmojiListReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MyEmojiListReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MyEmojiListReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MyEmojiListReqMultiError,
// or nil if none found.
func (m *MyEmojiListReq) ValidateAll() error {
	return m.validate(true)
}

func (m *MyEmojiListReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	if len(errors) > 0 {
		return MyEmojiListReqMultiError(errors)
	}

	return nil
}

// MyEmojiListReqMultiError is an error wrapping multiple validation errors
// returned by MyEmojiListReq.ValidateAll() if the designated constraints
// aren't met.
type MyEmojiListReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MyEmojiListReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MyEmojiListReqMultiError) AllErrors() []error { return m }

// MyEmojiListReqValidationError is the validation error returned by
// MyEmojiListReq.Validate if the designated constraints aren't met.
type MyEmojiListReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MyEmojiListReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MyEmojiListReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MyEmojiListReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MyEmojiListReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MyEmojiListReqValidationError) ErrorName() string { return "MyEmojiListReqValidationError" }

// Error satisfies the builtin error interface
func (e MyEmojiListReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMyEmojiListReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MyEmojiListReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MyEmojiListReqValidationError{}

// Validate checks the field values on MyEmojiListRes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MyEmojiListRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MyEmojiListRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MyEmojiListResMultiError,
// or nil if none found.
func (m *MyEmojiListRes) ValidateAll() error {
	return m.validate(true)
}

func (m *MyEmojiListRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetMap()))
		i := 0
		for key := range m.GetMap() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetMap()[key]
			_ = val

			// no validation rules for Map[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, MyEmojiListResValidationError{
							field:  fmt.Sprintf("Map[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, MyEmojiListResValidationError{
							field:  fmt.Sprintf("Map[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return MyEmojiListResValidationError{
						field:  fmt.Sprintf("Map[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return MyEmojiListResMultiError(errors)
	}

	return nil
}

// MyEmojiListResMultiError is an error wrapping multiple validation errors
// returned by MyEmojiListRes.ValidateAll() if the designated constraints
// aren't met.
type MyEmojiListResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MyEmojiListResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MyEmojiListResMultiError) AllErrors() []error { return m }

// MyEmojiListResValidationError is the validation error returned by
// MyEmojiListRes.Validate if the designated constraints aren't met.
type MyEmojiListResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MyEmojiListResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MyEmojiListResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MyEmojiListResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MyEmojiListResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MyEmojiListResValidationError) ErrorName() string { return "MyEmojiListResValidationError" }

// Error satisfies the builtin error interface
func (e MyEmojiListResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMyEmojiListRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MyEmojiListResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MyEmojiListResValidationError{}

// Validate checks the field values on MyEmojiListByFileGuidsReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MyEmojiListByFileGuidsReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MyEmojiListByFileGuidsReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MyEmojiListByFileGuidsReqMultiError, or nil if none found.
func (m *MyEmojiListByFileGuidsReq) ValidateAll() error {
	return m.validate(true)
}

func (m *MyEmojiListByFileGuidsReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	if len(errors) > 0 {
		return MyEmojiListByFileGuidsReqMultiError(errors)
	}

	return nil
}

// MyEmojiListByFileGuidsReqMultiError is an error wrapping multiple validation
// errors returned by MyEmojiListByFileGuidsReq.ValidateAll() if the
// designated constraints aren't met.
type MyEmojiListByFileGuidsReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MyEmojiListByFileGuidsReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MyEmojiListByFileGuidsReqMultiError) AllErrors() []error { return m }

// MyEmojiListByFileGuidsReqValidationError is the validation error returned by
// MyEmojiListByFileGuidsReq.Validate if the designated constraints aren't met.
type MyEmojiListByFileGuidsReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MyEmojiListByFileGuidsReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MyEmojiListByFileGuidsReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MyEmojiListByFileGuidsReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MyEmojiListByFileGuidsReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MyEmojiListByFileGuidsReqValidationError) ErrorName() string {
	return "MyEmojiListByFileGuidsReqValidationError"
}

// Error satisfies the builtin error interface
func (e MyEmojiListByFileGuidsReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMyEmojiListByFileGuidsReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MyEmojiListByFileGuidsReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MyEmojiListByFileGuidsReqValidationError{}

// Validate checks the field values on MyEmojiListByFileGuidsRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MyEmojiListByFileGuidsRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MyEmojiListByFileGuidsRes with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MyEmojiListByFileGuidsResMultiError, or nil if none found.
func (m *MyEmojiListByFileGuidsRes) ValidateAll() error {
	return m.validate(true)
}

func (m *MyEmojiListByFileGuidsRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MyEmojiListByFileGuidsResValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MyEmojiListByFileGuidsResValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MyEmojiListByFileGuidsResValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MyEmojiListByFileGuidsResMultiError(errors)
	}

	return nil
}

// MyEmojiListByFileGuidsResMultiError is an error wrapping multiple validation
// errors returned by MyEmojiListByFileGuidsRes.ValidateAll() if the
// designated constraints aren't met.
type MyEmojiListByFileGuidsResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MyEmojiListByFileGuidsResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MyEmojiListByFileGuidsResMultiError) AllErrors() []error { return m }

// MyEmojiListByFileGuidsResValidationError is the validation error returned by
// MyEmojiListByFileGuidsRes.Validate if the designated constraints aren't met.
type MyEmojiListByFileGuidsResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MyEmojiListByFileGuidsResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MyEmojiListByFileGuidsResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MyEmojiListByFileGuidsResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MyEmojiListByFileGuidsResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MyEmojiListByFileGuidsResValidationError) ErrorName() string {
	return "MyEmojiListByFileGuidsResValidationError"
}

// Error satisfies the builtin error interface
func (e MyEmojiListByFileGuidsResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMyEmojiListByFileGuidsRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MyEmojiListByFileGuidsResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MyEmojiListByFileGuidsResValidationError{}

// Validate checks the field values on MyEmojiInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MyEmojiInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MyEmojiInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MyEmojiInfoMultiError, or
// nil if none found.
func (m *MyEmojiInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *MyEmojiInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Guid

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MyEmojiInfoValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MyEmojiInfoValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MyEmojiInfoValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MyEmojiInfoMultiError(errors)
	}

	return nil
}

// MyEmojiInfoMultiError is an error wrapping multiple validation errors
// returned by MyEmojiInfo.ValidateAll() if the designated constraints aren't met.
type MyEmojiInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MyEmojiInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MyEmojiInfoMultiError) AllErrors() []error { return m }

// MyEmojiInfoValidationError is the validation error returned by
// MyEmojiInfo.Validate if the designated constraints aren't met.
type MyEmojiInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MyEmojiInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MyEmojiInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MyEmojiInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MyEmojiInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MyEmojiInfoValidationError) ErrorName() string { return "MyEmojiInfoValidationError" }

// Error satisfies the builtin error interface
func (e MyEmojiInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMyEmojiInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MyEmojiInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MyEmojiInfoValidationError{}

// Validate checks the field values on EmojiMap with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EmojiMap) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EmojiMap with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EmojiMapMultiError, or nil
// if none found.
func (m *EmojiMap) ValidateAll() error {
	return m.validate(true)
}

func (m *EmojiMap) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]int32, len(m.GetMap()))
		i := 0
		for key := range m.GetMap() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetMap()[key]
			_ = val

			// no validation rules for Map[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, EmojiMapValidationError{
							field:  fmt.Sprintf("Map[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, EmojiMapValidationError{
							field:  fmt.Sprintf("Map[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return EmojiMapValidationError{
						field:  fmt.Sprintf("Map[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return EmojiMapMultiError(errors)
	}

	return nil
}

// EmojiMapMultiError is an error wrapping multiple validation errors returned
// by EmojiMap.ValidateAll() if the designated constraints aren't met.
type EmojiMapMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EmojiMapMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EmojiMapMultiError) AllErrors() []error { return m }

// EmojiMapValidationError is the validation error returned by
// EmojiMap.Validate if the designated constraints aren't met.
type EmojiMapValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmojiMapValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmojiMapValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmojiMapValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmojiMapValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmojiMapValidationError) ErrorName() string { return "EmojiMapValidationError" }

// Error satisfies the builtin error interface
func (e EmojiMapValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmojiMap.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmojiMapValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmojiMapValidationError{}

// Validate checks the field values on ArticleShow with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ArticleShow) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ArticleShow with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ArticleShowMultiError, or
// nil if none found.
func (m *ArticleShow) ValidateAll() error {
	return m.validate(true)
}

func (m *ArticleShow) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Guid

	// no validation rules for Name

	// no validation rules for Uid

	// no validation rules for Nickname

	// no validation rules for Avatar

	// no validation rules for Summary

	// no validation rules for Ctime

	// no validation rules for CntComment

	// no validation rules for CntView

	// no validation rules for CntCollect

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ArticleShowValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ArticleShowValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ArticleShowValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for HeadImage

	// no validation rules for SpaceGuid

	// no validation rules for IsReadMore

	// no validation rules for IsAllowCreateComment

	// no validation rules for IsCollect

	// no validation rules for BizStatus

	if len(errors) > 0 {
		return ArticleShowMultiError(errors)
	}

	return nil
}

// ArticleShowMultiError is an error wrapping multiple validation errors
// returned by ArticleShow.ValidateAll() if the designated constraints aren't met.
type ArticleShowMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ArticleShowMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ArticleShowMultiError) AllErrors() []error { return m }

// ArticleShowValidationError is the validation error returned by
// ArticleShow.Validate if the designated constraints aren't met.
type ArticleShowValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ArticleShowValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ArticleShowValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ArticleShowValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ArticleShowValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ArticleShowValidationError) ErrorName() string { return "ArticleShowValidationError" }

// Error satisfies the builtin error interface
func (e ArticleShowValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sArticleShow.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ArticleShowValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ArticleShowValidationError{}

// Validate checks the field values on CollectionCreateReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CollectionCreateReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CollectionCreateReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CollectionCreateReqMultiError, or nil if none found.
func (m *CollectionCreateReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CollectionCreateReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	// no validation rules for BizGuid

	// no validation rules for BizType

	if len(errors) > 0 {
		return CollectionCreateReqMultiError(errors)
	}

	return nil
}

// CollectionCreateReqMultiError is an error wrapping multiple validation
// errors returned by CollectionCreateReq.ValidateAll() if the designated
// constraints aren't met.
type CollectionCreateReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionCreateReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionCreateReqMultiError) AllErrors() []error { return m }

// CollectionCreateReqValidationError is the validation error returned by
// CollectionCreateReq.Validate if the designated constraints aren't met.
type CollectionCreateReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionCreateReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionCreateReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionCreateReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionCreateReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionCreateReqValidationError) ErrorName() string {
	return "CollectionCreateReqValidationError"
}

// Error satisfies the builtin error interface
func (e CollectionCreateReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollectionCreateReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionCreateReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionCreateReqValidationError{}

// Validate checks the field values on CollectionCreateRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CollectionCreateRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CollectionCreateRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CollectionCreateResMultiError, or nil if none found.
func (m *CollectionCreateRes) ValidateAll() error {
	return m.validate(true)
}

func (m *CollectionCreateRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Delta

	if len(errors) > 0 {
		return CollectionCreateResMultiError(errors)
	}

	return nil
}

// CollectionCreateResMultiError is an error wrapping multiple validation
// errors returned by CollectionCreateRes.ValidateAll() if the designated
// constraints aren't met.
type CollectionCreateResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionCreateResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionCreateResMultiError) AllErrors() []error { return m }

// CollectionCreateResValidationError is the validation error returned by
// CollectionCreateRes.Validate if the designated constraints aren't met.
type CollectionCreateResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionCreateResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionCreateResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionCreateResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionCreateResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionCreateResValidationError) ErrorName() string {
	return "CollectionCreateResValidationError"
}

// Error satisfies the builtin error interface
func (e CollectionCreateResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollectionCreateRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionCreateResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionCreateResValidationError{}

// Validate checks the field values on CollectionDeleteReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CollectionDeleteReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CollectionDeleteReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CollectionDeleteReqMultiError, or nil if none found.
func (m *CollectionDeleteReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CollectionDeleteReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	// no validation rules for BizGuid

	// no validation rules for BizType

	if len(errors) > 0 {
		return CollectionDeleteReqMultiError(errors)
	}

	return nil
}

// CollectionDeleteReqMultiError is an error wrapping multiple validation
// errors returned by CollectionDeleteReq.ValidateAll() if the designated
// constraints aren't met.
type CollectionDeleteReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionDeleteReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionDeleteReqMultiError) AllErrors() []error { return m }

// CollectionDeleteReqValidationError is the validation error returned by
// CollectionDeleteReq.Validate if the designated constraints aren't met.
type CollectionDeleteReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionDeleteReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionDeleteReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionDeleteReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionDeleteReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionDeleteReqValidationError) ErrorName() string {
	return "CollectionDeleteReqValidationError"
}

// Error satisfies the builtin error interface
func (e CollectionDeleteReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollectionDeleteReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionDeleteReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionDeleteReqValidationError{}

// Validate checks the field values on CollectionDeleteRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CollectionDeleteRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CollectionDeleteRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CollectionDeleteResMultiError, or nil if none found.
func (m *CollectionDeleteRes) ValidateAll() error {
	return m.validate(true)
}

func (m *CollectionDeleteRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Delta

	if len(errors) > 0 {
		return CollectionDeleteResMultiError(errors)
	}

	return nil
}

// CollectionDeleteResMultiError is an error wrapping multiple validation
// errors returned by CollectionDeleteRes.ValidateAll() if the designated
// constraints aren't met.
type CollectionDeleteResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CollectionDeleteResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CollectionDeleteResMultiError) AllErrors() []error { return m }

// CollectionDeleteResValidationError is the validation error returned by
// CollectionDeleteRes.Validate if the designated constraints aren't met.
type CollectionDeleteResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CollectionDeleteResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CollectionDeleteResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CollectionDeleteResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CollectionDeleteResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CollectionDeleteResValidationError) ErrorName() string {
	return "CollectionDeleteResValidationError"
}

// Error satisfies the builtin error interface
func (e CollectionDeleteResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCollectionDeleteRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CollectionDeleteResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CollectionDeleteResValidationError{}

// Validate checks the field values on PermissionReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PermissionReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PermissionReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PermissionReqMultiError, or
// nil if none found.
func (m *PermissionReq) ValidateAll() error {
	return m.validate(true)
}

func (m *PermissionReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	// no validation rules for FileGuid

	if len(errors) > 0 {
		return PermissionReqMultiError(errors)
	}

	return nil
}

// PermissionReqMultiError is an error wrapping multiple validation errors
// returned by PermissionReq.ValidateAll() if the designated constraints
// aren't met.
type PermissionReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PermissionReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PermissionReqMultiError) AllErrors() []error { return m }

// PermissionReqValidationError is the validation error returned by
// PermissionReq.Validate if the designated constraints aren't met.
type PermissionReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PermissionReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PermissionReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PermissionReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PermissionReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PermissionReqValidationError) ErrorName() string { return "PermissionReqValidationError" }

// Error satisfies the builtin error interface
func (e PermissionReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPermissionReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PermissionReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PermissionReqValidationError{}

// Validate checks the field values on PermissionRes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PermissionRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PermissionRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PermissionResMultiError, or
// nil if none found.
func (m *PermissionRes) ValidateAll() error {
	return m.validate(true)
}

func (m *PermissionRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Guid

	// no validation rules for IsAllowWrite

	// no validation rules for IsAllowDelete

	// no validation rules for IsAllowSiteTop

	// no validation rules for IsAllowRecommend

	// no validation rules for IsAllowSetComment

	// no validation rules for IsAllowCreateComment

	if len(errors) > 0 {
		return PermissionResMultiError(errors)
	}

	return nil
}

// PermissionResMultiError is an error wrapping multiple validation errors
// returned by PermissionRes.ValidateAll() if the designated constraints
// aren't met.
type PermissionResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PermissionResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PermissionResMultiError) AllErrors() []error { return m }

// PermissionResValidationError is the validation error returned by
// PermissionRes.Validate if the designated constraints aren't met.
type PermissionResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PermissionResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PermissionResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PermissionResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PermissionResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PermissionResValidationError) ErrorName() string { return "PermissionResValidationError" }

// Error satisfies the builtin error interface
func (e PermissionResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPermissionRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PermissionResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PermissionResValidationError{}

// Validate checks the field values on DriveNode with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DriveNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DriveNode with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DriveNodeMultiError, or nil
// if none found.
func (m *DriveNode) ValidateAll() error {
	return m.validate(true)
}

func (m *DriveNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Desc

	// no validation rules for Type

	// no validation rules for Format

	// no validation rules for Size

	if len(errors) > 0 {
		return DriveNodeMultiError(errors)
	}

	return nil
}

// DriveNodeMultiError is an error wrapping multiple validation errors returned
// by DriveNode.ValidateAll() if the designated constraints aren't met.
type DriveNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DriveNodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DriveNodeMultiError) AllErrors() []error { return m }

// DriveNodeValidationError is the validation error returned by
// DriveNode.Validate if the designated constraints aren't met.
type DriveNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DriveNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DriveNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DriveNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DriveNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DriveNodeValidationError) ErrorName() string { return "DriveNodeValidationError" }

// Error satisfies the builtin error interface
func (e DriveNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDriveNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DriveNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DriveNodeValidationError{}

// Validate checks the field values on UpdateFileSizeReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdateFileSizeReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateFileSizeReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateFileSizeReqMultiError, or nil if none found.
func (m *UpdateFileSizeReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateFileSizeReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SpaceGuid

	// no validation rules for Guid

	// no validation rules for Size

	// no validation rules for Uid

	if len(errors) > 0 {
		return UpdateFileSizeReqMultiError(errors)
	}

	return nil
}

// UpdateFileSizeReqMultiError is an error wrapping multiple validation errors
// returned by UpdateFileSizeReq.ValidateAll() if the designated constraints
// aren't met.
type UpdateFileSizeReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateFileSizeReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateFileSizeReqMultiError) AllErrors() []error { return m }

// UpdateFileSizeReqValidationError is the validation error returned by
// UpdateFileSizeReq.Validate if the designated constraints aren't met.
type UpdateFileSizeReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateFileSizeReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateFileSizeReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateFileSizeReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateFileSizeReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateFileSizeReqValidationError) ErrorName() string {
	return "UpdateFileSizeReqValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateFileSizeReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateFileSizeReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateFileSizeReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateFileSizeReqValidationError{}

// Validate checks the field values on UpdateFileSizeRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdateFileSizeRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateFileSizeRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateFileSizeResMultiError, or nil if none found.
func (m *UpdateFileSizeRes) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateFileSizeRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UpdateFileSizeResMultiError(errors)
	}

	return nil
}

// UpdateFileSizeResMultiError is an error wrapping multiple validation errors
// returned by UpdateFileSizeRes.ValidateAll() if the designated constraints
// aren't met.
type UpdateFileSizeResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateFileSizeResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateFileSizeResMultiError) AllErrors() []error { return m }

// UpdateFileSizeResValidationError is the validation error returned by
// UpdateFileSizeRes.Validate if the designated constraints aren't met.
type UpdateFileSizeResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateFileSizeResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateFileSizeResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateFileSizeResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateFileSizeResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateFileSizeResValidationError) ErrorName() string {
	return "UpdateFileSizeResValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateFileSizeResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateFileSizeRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateFileSizeResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateFileSizeResValidationError{}

// Validate checks the field values on ListPageByParentReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListPageByParentReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListPageByParentReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListPageByParentReqMultiError, or nil if none found.
func (m *ListPageByParentReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListPageByParentReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	// no validation rules for ParentGuid

	if all {
		switch v := interface{}(m.GetPagination()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListPageByParentReqValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListPageByParentReqValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPagination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListPageByParentReqValidationError{
				field:  "Pagination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Sort

	if len(errors) > 0 {
		return ListPageByParentReqMultiError(errors)
	}

	return nil
}

// ListPageByParentReqMultiError is an error wrapping multiple validation
// errors returned by ListPageByParentReq.ValidateAll() if the designated
// constraints aren't met.
type ListPageByParentReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListPageByParentReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListPageByParentReqMultiError) AllErrors() []error { return m }

// ListPageByParentReqValidationError is the validation error returned by
// ListPageByParentReq.Validate if the designated constraints aren't met.
type ListPageByParentReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListPageByParentReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListPageByParentReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListPageByParentReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListPageByParentReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListPageByParentReqValidationError) ErrorName() string {
	return "ListPageByParentReqValidationError"
}

// Error satisfies the builtin error interface
func (e ListPageByParentReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListPageByParentReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListPageByParentReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListPageByParentReqValidationError{}

// Validate checks the field values on ListPageByParentRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListPageByParentRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListPageByParentRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListPageByParentResMultiError, or nil if none found.
func (m *ListPageByParentRes) ValidateAll() error {
	return m.validate(true)
}

func (m *ListPageByParentRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListPageByParentResValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListPageByParentResValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListPageByParentResValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetPagination()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListPageByParentResValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListPageByParentResValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPagination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListPageByParentResValidationError{
				field:  "Pagination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListPageByParentResMultiError(errors)
	}

	return nil
}

// ListPageByParentResMultiError is an error wrapping multiple validation
// errors returned by ListPageByParentRes.ValidateAll() if the designated
// constraints aren't met.
type ListPageByParentResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListPageByParentResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListPageByParentResMultiError) AllErrors() []error { return m }

// ListPageByParentResValidationError is the validation error returned by
// ListPageByParentRes.Validate if the designated constraints aren't met.
type ListPageByParentResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListPageByParentResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListPageByParentResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListPageByParentResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListPageByParentResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListPageByParentResValidationError) ErrorName() string {
	return "ListPageByParentResValidationError"
}

// Error satisfies the builtin error interface
func (e ListPageByParentResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListPageByParentRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListPageByParentResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListPageByParentResValidationError{}

// Validate checks the field values on PermissionListReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PermissionListReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PermissionListReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PermissionListReqMultiError, or nil if none found.
func (m *PermissionListReq) ValidateAll() error {
	return m.validate(true)
}

func (m *PermissionListReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	if len(errors) > 0 {
		return PermissionListReqMultiError(errors)
	}

	return nil
}

// PermissionListReqMultiError is an error wrapping multiple validation errors
// returned by PermissionListReq.ValidateAll() if the designated constraints
// aren't met.
type PermissionListReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PermissionListReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PermissionListReqMultiError) AllErrors() []error { return m }

// PermissionListReqValidationError is the validation error returned by
// PermissionListReq.Validate if the designated constraints aren't met.
type PermissionListReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PermissionListReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PermissionListReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PermissionListReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PermissionListReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PermissionListReqValidationError) ErrorName() string {
	return "PermissionListReqValidationError"
}

// Error satisfies the builtin error interface
func (e PermissionListReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPermissionListReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PermissionListReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PermissionListReqValidationError{}

// Validate checks the field values on PermissionListRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PermissionListRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PermissionListRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PermissionListResMultiError, or nil if none found.
func (m *PermissionListRes) ValidateAll() error {
	return m.validate(true)
}

func (m *PermissionListRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PermissionListResValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PermissionListResValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PermissionListResValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PermissionListResMultiError(errors)
	}

	return nil
}

// PermissionListResMultiError is an error wrapping multiple validation errors
// returned by PermissionListRes.ValidateAll() if the designated constraints
// aren't met.
type PermissionListResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PermissionListResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PermissionListResMultiError) AllErrors() []error { return m }

// PermissionListResValidationError is the validation error returned by
// PermissionListRes.Validate if the designated constraints aren't met.
type PermissionListResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PermissionListResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PermissionListResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PermissionListResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PermissionListResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PermissionListResValidationError) ErrorName() string {
	return "PermissionListResValidationError"
}

// Error satisfies the builtin error interface
func (e PermissionListResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPermissionListRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PermissionListResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PermissionListResValidationError{}

// Validate checks the field values on CloseCommentReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CloseCommentReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CloseCommentReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CloseCommentReqMultiError, or nil if none found.
func (m *CloseCommentReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CloseCommentReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	// no validation rules for Guid

	if len(errors) > 0 {
		return CloseCommentReqMultiError(errors)
	}

	return nil
}

// CloseCommentReqMultiError is an error wrapping multiple validation errors
// returned by CloseCommentReq.ValidateAll() if the designated constraints
// aren't met.
type CloseCommentReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CloseCommentReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CloseCommentReqMultiError) AllErrors() []error { return m }

// CloseCommentReqValidationError is the validation error returned by
// CloseCommentReq.Validate if the designated constraints aren't met.
type CloseCommentReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CloseCommentReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CloseCommentReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CloseCommentReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CloseCommentReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CloseCommentReqValidationError) ErrorName() string { return "CloseCommentReqValidationError" }

// Error satisfies the builtin error interface
func (e CloseCommentReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCloseCommentReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CloseCommentReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CloseCommentReqValidationError{}

// Validate checks the field values on CloseCommentRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CloseCommentRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CloseCommentRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CloseCommentResMultiError, or nil if none found.
func (m *CloseCommentRes) ValidateAll() error {
	return m.validate(true)
}

func (m *CloseCommentRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return CloseCommentResMultiError(errors)
	}

	return nil
}

// CloseCommentResMultiError is an error wrapping multiple validation errors
// returned by CloseCommentRes.ValidateAll() if the designated constraints
// aren't met.
type CloseCommentResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CloseCommentResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CloseCommentResMultiError) AllErrors() []error { return m }

// CloseCommentResValidationError is the validation error returned by
// CloseCommentRes.Validate if the designated constraints aren't met.
type CloseCommentResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CloseCommentResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CloseCommentResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CloseCommentResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CloseCommentResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CloseCommentResValidationError) ErrorName() string { return "CloseCommentResValidationError" }

// Error satisfies the builtin error interface
func (e CloseCommentResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCloseCommentRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CloseCommentResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CloseCommentResValidationError{}

// Validate checks the field values on OpenCommentReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OpenCommentReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OpenCommentReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OpenCommentReqMultiError,
// or nil if none found.
func (m *OpenCommentReq) ValidateAll() error {
	return m.validate(true)
}

func (m *OpenCommentReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	// no validation rules for Guid

	if len(errors) > 0 {
		return OpenCommentReqMultiError(errors)
	}

	return nil
}

// OpenCommentReqMultiError is an error wrapping multiple validation errors
// returned by OpenCommentReq.ValidateAll() if the designated constraints
// aren't met.
type OpenCommentReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OpenCommentReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OpenCommentReqMultiError) AllErrors() []error { return m }

// OpenCommentReqValidationError is the validation error returned by
// OpenCommentReq.Validate if the designated constraints aren't met.
type OpenCommentReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OpenCommentReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OpenCommentReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OpenCommentReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OpenCommentReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OpenCommentReqValidationError) ErrorName() string { return "OpenCommentReqValidationError" }

// Error satisfies the builtin error interface
func (e OpenCommentReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOpenCommentReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OpenCommentReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OpenCommentReqValidationError{}

// Validate checks the field values on OpenCommentRes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OpenCommentRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OpenCommentRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OpenCommentResMultiError,
// or nil if none found.
func (m *OpenCommentRes) ValidateAll() error {
	return m.validate(true)
}

func (m *OpenCommentRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return OpenCommentResMultiError(errors)
	}

	return nil
}

// OpenCommentResMultiError is an error wrapping multiple validation errors
// returned by OpenCommentRes.ValidateAll() if the designated constraints
// aren't met.
type OpenCommentResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OpenCommentResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OpenCommentResMultiError) AllErrors() []error { return m }

// OpenCommentResValidationError is the validation error returned by
// OpenCommentRes.Validate if the designated constraints aren't met.
type OpenCommentResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OpenCommentResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OpenCommentResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OpenCommentResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OpenCommentResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OpenCommentResValidationError) ErrorName() string { return "OpenCommentResValidationError" }

// Error satisfies the builtin error interface
func (e OpenCommentResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOpenCommentRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OpenCommentResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OpenCommentResValidationError{}
