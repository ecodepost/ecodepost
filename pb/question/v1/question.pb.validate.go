// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: question/v1/question.proto

package questionv1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	commonv1 "ecodepost/pb/common/v1"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = commonv1.CMN_FILE_SORT(0)
)

// Validate checks the field values on CreateReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreateReqMultiError, or nil
// if none found.
func (m *CreateReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUid() <= 0 {
		err := CreateReqValidationError{
			field:  "Uid",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Name

	// no validation rules for SpaceGuid

	// no validation rules for ParentGuid

	if utf8.RuneCountInString(m.GetContent()) < 1 {
		err := CreateReqValidationError{
			field:  "Content",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Ip

	if len(errors) > 0 {
		return CreateReqMultiError(errors)
	}

	return nil
}

// CreateReqMultiError is an error wrapping multiple validation errors returned
// by CreateReq.ValidateAll() if the designated constraints aren't met.
type CreateReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateReqMultiError) AllErrors() []error { return m }

// CreateReqValidationError is the validation error returned by
// CreateReq.Validate if the designated constraints aren't met.
type CreateReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateReqValidationError) ErrorName() string { return "CreateReqValidationError" }

// Error satisfies the builtin error interface
func (e CreateReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateReqValidationError{}

// Validate checks the field values on CreateRes with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateRes with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreateResMultiError, or nil
// if none found.
func (m *CreateRes) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFile()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateResValidationError{
					field:  "File",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateResValidationError{
					field:  "File",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFile()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateResValidationError{
				field:  "File",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateResMultiError(errors)
	}

	return nil
}

// CreateResMultiError is an error wrapping multiple validation errors returned
// by CreateRes.ValidateAll() if the designated constraints aren't met.
type CreateResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateResMultiError) AllErrors() []error { return m }

// CreateResValidationError is the validation error returned by
// CreateRes.Validate if the designated constraints aren't met.
type CreateResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateResValidationError) ErrorName() string { return "CreateResValidationError" }

// Error satisfies the builtin error interface
func (e CreateResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateResValidationError{}

// Validate checks the field values on UpdateReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UpdateReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UpdateReqMultiError, or nil
// if none found.
func (m *UpdateReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUid() <= 0 {
		err := UpdateReqValidationError{
			field:  "Uid",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetGuid()) < 1 {
		err := UpdateReqValidationError{
			field:  "Guid",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Name

	// no validation rules for FileFormat

	if m.Content != nil {
		// no validation rules for Content
	}

	if len(errors) > 0 {
		return UpdateReqMultiError(errors)
	}

	return nil
}

// UpdateReqMultiError is an error wrapping multiple validation errors returned
// by UpdateReq.ValidateAll() if the designated constraints aren't met.
type UpdateReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateReqMultiError) AllErrors() []error { return m }

// UpdateReqValidationError is the validation error returned by
// UpdateReq.Validate if the designated constraints aren't met.
type UpdateReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateReqValidationError) ErrorName() string { return "UpdateReqValidationError" }

// Error satisfies the builtin error interface
func (e UpdateReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateReqValidationError{}

// Validate checks the field values on UpdateRes with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UpdateRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateRes with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UpdateResMultiError, or nil
// if none found.
func (m *UpdateRes) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UpdateResMultiError(errors)
	}

	return nil
}

// UpdateResMultiError is an error wrapping multiple validation errors returned
// by UpdateRes.ValidateAll() if the designated constraints aren't met.
type UpdateResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateResMultiError) AllErrors() []error { return m }

// UpdateResValidationError is the validation error returned by
// UpdateRes.Validate if the designated constraints aren't met.
type UpdateResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateResValidationError) ErrorName() string { return "UpdateResValidationError" }

// Error satisfies the builtin error interface
func (e UpdateResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateResValidationError{}

// Validate checks the field values on MyInfoReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MyInfoReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MyInfoReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MyInfoReqMultiError, or nil
// if none found.
func (m *MyInfoReq) ValidateAll() error {
	return m.validate(true)
}

func (m *MyInfoReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	if utf8.RuneCountInString(m.GetGuid()) < 1 {
		err := MyInfoReqValidationError{
			field:  "Guid",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return MyInfoReqMultiError(errors)
	}

	return nil
}

// MyInfoReqMultiError is an error wrapping multiple validation errors returned
// by MyInfoReq.ValidateAll() if the designated constraints aren't met.
type MyInfoReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MyInfoReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MyInfoReqMultiError) AllErrors() []error { return m }

// MyInfoReqValidationError is the validation error returned by
// MyInfoReq.Validate if the designated constraints aren't met.
type MyInfoReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MyInfoReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MyInfoReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MyInfoReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MyInfoReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MyInfoReqValidationError) ErrorName() string { return "MyInfoReqValidationError" }

// Error satisfies the builtin error interface
func (e MyInfoReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMyInfoReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MyInfoReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MyInfoReqValidationError{}

// Validate checks the field values on MyInfoRes with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MyInfoRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MyInfoRes with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MyInfoResMultiError, or nil
// if none found.
func (m *MyInfoRes) ValidateAll() error {
	return m.validate(true)
}

func (m *MyInfoRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MyAnswerGuid

	if len(errors) > 0 {
		return MyInfoResMultiError(errors)
	}

	return nil
}

// MyInfoResMultiError is an error wrapping multiple validation errors returned
// by MyInfoRes.ValidateAll() if the designated constraints aren't met.
type MyInfoResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MyInfoResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MyInfoResMultiError) AllErrors() []error { return m }

// MyInfoResValidationError is the validation error returned by
// MyInfoRes.Validate if the designated constraints aren't met.
type MyInfoResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MyInfoResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MyInfoResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MyInfoResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MyInfoResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MyInfoResValidationError) ErrorName() string { return "MyInfoResValidationError" }

// Error satisfies the builtin error interface
func (e MyInfoResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMyInfoRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MyInfoResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MyInfoResValidationError{}

// Validate checks the field values on GetContentByCreatorReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetContentByCreatorReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetContentByCreatorReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetContentByCreatorReqMultiError, or nil if none found.
func (m *GetContentByCreatorReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetContentByCreatorReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUid() <= 0 {
		err := GetContentByCreatorReqValidationError{
			field:  "Uid",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetGuid()) < 1 {
		err := GetContentByCreatorReqValidationError{
			field:  "Guid",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetContentByCreatorReqMultiError(errors)
	}

	return nil
}

// GetContentByCreatorReqMultiError is an error wrapping multiple validation
// errors returned by GetContentByCreatorReq.ValidateAll() if the designated
// constraints aren't met.
type GetContentByCreatorReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetContentByCreatorReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetContentByCreatorReqMultiError) AllErrors() []error { return m }

// GetContentByCreatorReqValidationError is the validation error returned by
// GetContentByCreatorReq.Validate if the designated constraints aren't met.
type GetContentByCreatorReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetContentByCreatorReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetContentByCreatorReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetContentByCreatorReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetContentByCreatorReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetContentByCreatorReqValidationError) ErrorName() string {
	return "GetContentByCreatorReqValidationError"
}

// Error satisfies the builtin error interface
func (e GetContentByCreatorReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetContentByCreatorReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetContentByCreatorReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetContentByCreatorReqValidationError{}

// Validate checks the field values on GetContentByCreatorRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetContentByCreatorRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetContentByCreatorRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetContentByCreatorResMultiError, or nil if none found.
func (m *GetContentByCreatorRes) ValidateAll() error {
	return m.validate(true)
}

func (m *GetContentByCreatorRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Content

	if len(errors) > 0 {
		return GetContentByCreatorResMultiError(errors)
	}

	return nil
}

// GetContentByCreatorResMultiError is an error wrapping multiple validation
// errors returned by GetContentByCreatorRes.ValidateAll() if the designated
// constraints aren't met.
type GetContentByCreatorResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetContentByCreatorResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetContentByCreatorResMultiError) AllErrors() []error { return m }

// GetContentByCreatorResValidationError is the validation error returned by
// GetContentByCreatorRes.Validate if the designated constraints aren't met.
type GetContentByCreatorResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetContentByCreatorResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetContentByCreatorResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetContentByCreatorResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetContentByCreatorResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetContentByCreatorResValidationError) ErrorName() string {
	return "GetContentByCreatorResValidationError"
}

// Error satisfies the builtin error interface
func (e GetContentByCreatorResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetContentByCreatorRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetContentByCreatorResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetContentByCreatorResValidationError{}

// Validate checks the field values on GetContentReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetContentReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetContentReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetContentReqMultiError, or
// nil if none found.
func (m *GetContentReq) ValidateAll() error {
	return m.validate(true)
}

func (m *GetContentReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	if utf8.RuneCountInString(m.GetGuid()) < 1 {
		err := GetContentReqValidationError{
			field:  "Guid",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetContentReqMultiError(errors)
	}

	return nil
}

// GetContentReqMultiError is an error wrapping multiple validation errors
// returned by GetContentReq.ValidateAll() if the designated constraints
// aren't met.
type GetContentReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetContentReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetContentReqMultiError) AllErrors() []error { return m }

// GetContentReqValidationError is the validation error returned by
// GetContentReq.Validate if the designated constraints aren't met.
type GetContentReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetContentReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetContentReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetContentReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetContentReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetContentReqValidationError) ErrorName() string { return "GetContentReqValidationError" }

// Error satisfies the builtin error interface
func (e GetContentReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetContentReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetContentReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetContentReqValidationError{}

// Validate checks the field values on GetContentRes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetContentRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetContentRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetContentResMultiError, or
// nil if none found.
func (m *GetContentRes) ValidateAll() error {
	return m.validate(true)
}

func (m *GetContentRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Url

	if len(errors) > 0 {
		return GetContentResMultiError(errors)
	}

	return nil
}

// GetContentResMultiError is an error wrapping multiple validation errors
// returned by GetContentRes.ValidateAll() if the designated constraints
// aren't met.
type GetContentResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetContentResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetContentResMultiError) AllErrors() []error { return m }

// GetContentResValidationError is the validation error returned by
// GetContentRes.Validate if the designated constraints aren't met.
type GetContentResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetContentResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetContentResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetContentResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetContentResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetContentResValidationError) ErrorName() string { return "GetContentResValidationError" }

// Error satisfies the builtin error interface
func (e GetContentResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetContentRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetContentResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetContentResValidationError{}

// Validate checks the field values on QuestionShow with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *QuestionShow) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QuestionShow with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in QuestionShowMultiError, or
// nil if none found.
func (m *QuestionShow) ValidateAll() error {
	return m.validate(true)
}

func (m *QuestionShow) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Guid

	// no validation rules for Name

	// no validation rules for Uid

	// no validation rules for Nickname

	// no validation rules for Avatar

	// no validation rules for Summary

	// no validation rules for Ctime

	// no validation rules for CntComment

	// no validation rules for CntView

	// no validation rules for CntCollect

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QuestionShowValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QuestionShowValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QuestionShowValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Content

	// no validation rules for SpaceGuid

	// no validation rules for IsReadMore

	// no validation rules for IsAllowCreateComment

	// no validation rules for IsCollect

	// no validation rules for Format

	// no validation rules for IpLocation

	if len(errors) > 0 {
		return QuestionShowMultiError(errors)
	}

	return nil
}

// QuestionShowMultiError is an error wrapping multiple validation errors
// returned by QuestionShow.ValidateAll() if the designated constraints aren't met.
type QuestionShowMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QuestionShowMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QuestionShowMultiError) AllErrors() []error { return m }

// QuestionShowValidationError is the validation error returned by
// QuestionShow.Validate if the designated constraints aren't met.
type QuestionShowValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QuestionShowValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QuestionShowValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QuestionShowValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QuestionShowValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QuestionShowValidationError) ErrorName() string { return "QuestionShowValidationError" }

// Error satisfies the builtin error interface
func (e QuestionShowValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQuestionShow.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QuestionShowValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QuestionShowValidationError{}

// Validate checks the field values on AnswerShow with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AnswerShow) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AnswerShow with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AnswerShowMultiError, or
// nil if none found.
func (m *AnswerShow) ValidateAll() error {
	return m.validate(true)
}

func (m *AnswerShow) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Guid

	// no validation rules for Name

	// no validation rules for Uid

	// no validation rules for Nickname

	// no validation rules for Avatar

	// no validation rules for Summary

	// no validation rules for Ctime

	// no validation rules for CntComment

	// no validation rules for CntView

	// no validation rules for CntCollect

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AnswerShowValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AnswerShowValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AnswerShowValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for SpaceGuid

	// no validation rules for IsReadMore

	// no validation rules for IsAllowCreateComment

	// no validation rules for IsCollect

	// no validation rules for Format

	// no validation rules for IpLocation

	if len(errors) > 0 {
		return AnswerShowMultiError(errors)
	}

	return nil
}

// AnswerShowMultiError is an error wrapping multiple validation errors
// returned by AnswerShow.ValidateAll() if the designated constraints aren't met.
type AnswerShowMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AnswerShowMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AnswerShowMultiError) AllErrors() []error { return m }

// AnswerShowValidationError is the validation error returned by
// AnswerShow.Validate if the designated constraints aren't met.
type AnswerShowValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AnswerShowValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AnswerShowValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AnswerShowValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AnswerShowValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AnswerShowValidationError) ErrorName() string { return "AnswerShowValidationError" }

// Error satisfies the builtin error interface
func (e AnswerShowValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAnswerShow.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AnswerShowValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AnswerShowValidationError{}

// Validate checks the field values on QAShow with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *QAShow) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QAShow with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in QAShowMultiError, or nil if none found.
func (m *QAShow) ValidateAll() error {
	return m.validate(true)
}

func (m *QAShow) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Guid

	// no validation rules for ParentGuid

	// no validation rules for Name

	// no validation rules for Uid

	// no validation rules for Nickname

	// no validation rules for Avatar

	// no validation rules for Summary

	// no validation rules for Ctime

	// no validation rules for CntComment

	// no validation rules for CntView

	// no validation rules for CntCollect

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QAShowValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QAShowValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QAShowValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Content

	// no validation rules for SpaceGuid

	// no validation rules for IsReadMore

	// no validation rules for IsAllowCreateComment

	// no validation rules for IsCollect

	// no validation rules for Format

	// no validation rules for IpLocation

	if len(errors) > 0 {
		return QAShowMultiError(errors)
	}

	return nil
}

// QAShowMultiError is an error wrapping multiple validation errors returned by
// QAShow.ValidateAll() if the designated constraints aren't met.
type QAShowMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QAShowMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QAShowMultiError) AllErrors() []error { return m }

// QAShowValidationError is the validation error returned by QAShow.Validate if
// the designated constraints aren't met.
type QAShowValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QAShowValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QAShowValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QAShowValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QAShowValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QAShowValidationError) ErrorName() string { return "QAShowValidationError" }

// Error satisfies the builtin error interface
func (e QAShowValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQAShow.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QAShowValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QAShowValidationError{}

// Validate checks the field values on DeleteReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeleteReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeleteReqMultiError, or nil
// if none found.
func (m *DeleteReq) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUid() <= 0 {
		err := DeleteReqValidationError{
			field:  "Uid",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetGuid()) < 1 {
		err := DeleteReqValidationError{
			field:  "Guid",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteReqMultiError(errors)
	}

	return nil
}

// DeleteReqMultiError is an error wrapping multiple validation errors returned
// by DeleteReq.ValidateAll() if the designated constraints aren't met.
type DeleteReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteReqMultiError) AllErrors() []error { return m }

// DeleteReqValidationError is the validation error returned by
// DeleteReq.Validate if the designated constraints aren't met.
type DeleteReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteReqValidationError) ErrorName() string { return "DeleteReqValidationError" }

// Error satisfies the builtin error interface
func (e DeleteReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteReqValidationError{}

// Validate checks the field values on DeleteRes with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeleteRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteRes with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeleteResMultiError, or nil
// if none found.
func (m *DeleteRes) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteResMultiError(errors)
	}

	return nil
}

// DeleteResMultiError is an error wrapping multiple validation errors returned
// by DeleteRes.ValidateAll() if the designated constraints aren't met.
type DeleteResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteResMultiError) AllErrors() []error { return m }

// DeleteResValidationError is the validation error returned by
// DeleteRes.Validate if the designated constraints aren't met.
type DeleteResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteResValidationError) ErrorName() string { return "DeleteResValidationError" }

// Error satisfies the builtin error interface
func (e DeleteResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteResValidationError{}

// Validate checks the field values on ListQuestionReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListQuestionReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListQuestionReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListQuestionReqMultiError, or nil if none found.
func (m *ListQuestionReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListQuestionReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	if utf8.RuneCountInString(m.GetSpaceGuid()) < 1 {
		err := ListQuestionReqValidationError{
			field:  "SpaceGuid",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetPagination()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListQuestionReqValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListQuestionReqValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPagination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListQuestionReqValidationError{
				field:  "Pagination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Sort

	if len(errors) > 0 {
		return ListQuestionReqMultiError(errors)
	}

	return nil
}

// ListQuestionReqMultiError is an error wrapping multiple validation errors
// returned by ListQuestionReq.ValidateAll() if the designated constraints
// aren't met.
type ListQuestionReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListQuestionReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListQuestionReqMultiError) AllErrors() []error { return m }

// ListQuestionReqValidationError is the validation error returned by
// ListQuestionReq.Validate if the designated constraints aren't met.
type ListQuestionReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListQuestionReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListQuestionReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListQuestionReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListQuestionReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListQuestionReqValidationError) ErrorName() string { return "ListQuestionReqValidationError" }

// Error satisfies the builtin error interface
func (e ListQuestionReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListQuestionReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListQuestionReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListQuestionReqValidationError{}

// Validate checks the field values on ListQuestionRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListQuestionRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListQuestionRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListQuestionResMultiError, or nil if none found.
func (m *ListQuestionRes) ValidateAll() error {
	return m.validate(true)
}

func (m *ListQuestionRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListQuestionResValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListQuestionResValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListQuestionResValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetPagination()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListQuestionResValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListQuestionResValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPagination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListQuestionResValidationError{
				field:  "Pagination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListQuestionResMultiError(errors)
	}

	return nil
}

// ListQuestionResMultiError is an error wrapping multiple validation errors
// returned by ListQuestionRes.ValidateAll() if the designated constraints
// aren't met.
type ListQuestionResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListQuestionResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListQuestionResMultiError) AllErrors() []error { return m }

// ListQuestionResValidationError is the validation error returned by
// ListQuestionRes.Validate if the designated constraints aren't met.
type ListQuestionResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListQuestionResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListQuestionResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListQuestionResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListQuestionResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListQuestionResValidationError) ErrorName() string { return "ListQuestionResValidationError" }

// Error satisfies the builtin error interface
func (e ListQuestionResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListQuestionRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListQuestionResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListQuestionResValidationError{}

// Validate checks the field values on ListAnswerReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListAnswerReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListAnswerReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListAnswerReqMultiError, or
// nil if none found.
func (m *ListAnswerReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListAnswerReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	if utf8.RuneCountInString(m.GetParentGuid()) < 1 {
		err := ListAnswerReqValidationError{
			field:  "ParentGuid",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetPagination()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListAnswerReqValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListAnswerReqValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPagination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListAnswerReqValidationError{
				field:  "Pagination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Sort

	if len(errors) > 0 {
		return ListAnswerReqMultiError(errors)
	}

	return nil
}

// ListAnswerReqMultiError is an error wrapping multiple validation errors
// returned by ListAnswerReq.ValidateAll() if the designated constraints
// aren't met.
type ListAnswerReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListAnswerReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListAnswerReqMultiError) AllErrors() []error { return m }

// ListAnswerReqValidationError is the validation error returned by
// ListAnswerReq.Validate if the designated constraints aren't met.
type ListAnswerReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListAnswerReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListAnswerReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListAnswerReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListAnswerReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListAnswerReqValidationError) ErrorName() string { return "ListAnswerReqValidationError" }

// Error satisfies the builtin error interface
func (e ListAnswerReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListAnswerReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListAnswerReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListAnswerReqValidationError{}

// Validate checks the field values on ListAnswerRes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListAnswerRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListAnswerRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListAnswerResMultiError, or
// nil if none found.
func (m *ListAnswerRes) ValidateAll() error {
	return m.validate(true)
}

func (m *ListAnswerRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListAnswerResValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListAnswerResValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListAnswerResValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetPagination()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListAnswerResValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListAnswerResValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPagination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListAnswerResValidationError{
				field:  "Pagination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListAnswerResMultiError(errors)
	}

	return nil
}

// ListAnswerResMultiError is an error wrapping multiple validation errors
// returned by ListAnswerRes.ValidateAll() if the designated constraints
// aren't met.
type ListAnswerResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListAnswerResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListAnswerResMultiError) AllErrors() []error { return m }

// ListAnswerResValidationError is the validation error returned by
// ListAnswerRes.Validate if the designated constraints aren't met.
type ListAnswerResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListAnswerResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListAnswerResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListAnswerResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListAnswerResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListAnswerResValidationError) ErrorName() string { return "ListAnswerResValidationError" }

// Error satisfies the builtin error interface
func (e ListAnswerResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListAnswerRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListAnswerResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListAnswerResValidationError{}

// Validate checks the field values on PublicListByUserCreatedReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PublicListByUserCreatedReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PublicListByUserCreatedReq with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PublicListByUserCreatedReqMultiError, or nil if none found.
func (m *PublicListByUserCreatedReq) ValidateAll() error {
	return m.validate(true)
}

func (m *PublicListByUserCreatedReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	if m.GetCreatedUid() <= 0 {
		err := PublicListByUserCreatedReqValidationError{
			field:  "CreatedUid",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetPagination()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PublicListByUserCreatedReqValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PublicListByUserCreatedReqValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPagination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PublicListByUserCreatedReqValidationError{
				field:  "Pagination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PublicListByUserCreatedReqMultiError(errors)
	}

	return nil
}

// PublicListByUserCreatedReqMultiError is an error wrapping multiple
// validation errors returned by PublicListByUserCreatedReq.ValidateAll() if
// the designated constraints aren't met.
type PublicListByUserCreatedReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PublicListByUserCreatedReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PublicListByUserCreatedReqMultiError) AllErrors() []error { return m }

// PublicListByUserCreatedReqValidationError is the validation error returned
// by PublicListByUserCreatedReq.Validate if the designated constraints aren't met.
type PublicListByUserCreatedReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PublicListByUserCreatedReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PublicListByUserCreatedReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PublicListByUserCreatedReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PublicListByUserCreatedReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PublicListByUserCreatedReqValidationError) ErrorName() string {
	return "PublicListByUserCreatedReqValidationError"
}

// Error satisfies the builtin error interface
func (e PublicListByUserCreatedReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPublicListByUserCreatedReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PublicListByUserCreatedReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PublicListByUserCreatedReqValidationError{}

// Validate checks the field values on PublicListByUserCreatedRes with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PublicListByUserCreatedRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PublicListByUserCreatedRes with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PublicListByUserCreatedResMultiError, or nil if none found.
func (m *PublicListByUserCreatedRes) ValidateAll() error {
	return m.validate(true)
}

func (m *PublicListByUserCreatedRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PublicListByUserCreatedResValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PublicListByUserCreatedResValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PublicListByUserCreatedResValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetPagination()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PublicListByUserCreatedResValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PublicListByUserCreatedResValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPagination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PublicListByUserCreatedResValidationError{
				field:  "Pagination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PublicListByUserCreatedResMultiError(errors)
	}

	return nil
}

// PublicListByUserCreatedResMultiError is an error wrapping multiple
// validation errors returned by PublicListByUserCreatedRes.ValidateAll() if
// the designated constraints aren't met.
type PublicListByUserCreatedResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PublicListByUserCreatedResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PublicListByUserCreatedResMultiError) AllErrors() []error { return m }

// PublicListByUserCreatedResValidationError is the validation error returned
// by PublicListByUserCreatedRes.Validate if the designated constraints aren't met.
type PublicListByUserCreatedResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PublicListByUserCreatedResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PublicListByUserCreatedResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PublicListByUserCreatedResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PublicListByUserCreatedResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PublicListByUserCreatedResValidationError) ErrorName() string {
	return "PublicListByUserCreatedResValidationError"
}

// Error satisfies the builtin error interface
func (e PublicListByUserCreatedResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPublicListByUserCreatedRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PublicListByUserCreatedResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PublicListByUserCreatedResValidationError{}
