// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: user/v1/user.proto

package userv1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	commonv1 "ecodepost/pb/common/v1"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = commonv1.AUDIT_STATUS(0)
)

// Validate checks the field values on ListPageReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListPageReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListPageReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListPageReqMultiError, or
// nil if none found.
func (m *ListPageReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListPageReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPagination()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListPageReqValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListPageReqValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPagination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListPageReqValidationError{
				field:  "Pagination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Uid != nil {
		// no validation rules for Uid
	}

	if m.Nickname != nil {
		// no validation rules for Nickname
	}

	if m.Phone != nil {
		// no validation rules for Phone
	}

	if len(errors) > 0 {
		return ListPageReqMultiError(errors)
	}

	return nil
}

// ListPageReqMultiError is an error wrapping multiple validation errors
// returned by ListPageReq.ValidateAll() if the designated constraints aren't met.
type ListPageReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListPageReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListPageReqMultiError) AllErrors() []error { return m }

// ListPageReqValidationError is the validation error returned by
// ListPageReq.Validate if the designated constraints aren't met.
type ListPageReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListPageReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListPageReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListPageReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListPageReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListPageReqValidationError) ErrorName() string { return "ListPageReqValidationError" }

// Error satisfies the builtin error interface
func (e ListPageReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListPageReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListPageReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListPageReqValidationError{}

// Validate checks the field values on ListPageRes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListPageRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListPageRes with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListPageResMultiError, or
// nil if none found.
func (m *ListPageRes) ValidateAll() error {
	return m.validate(true)
}

func (m *ListPageRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListPageResValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListPageResValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListPageResValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetPagination()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListPageResValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListPageResValidationError{
					field:  "Pagination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPagination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListPageResValidationError{
				field:  "Pagination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListPageResMultiError(errors)
	}

	return nil
}

// ListPageResMultiError is an error wrapping multiple validation errors
// returned by ListPageRes.ValidateAll() if the designated constraints aren't met.
type ListPageResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListPageResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListPageResMultiError) AllErrors() []error { return m }

// ListPageResValidationError is the validation error returned by
// ListPageRes.Validate if the designated constraints aren't met.
type ListPageResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListPageResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListPageResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListPageResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListPageResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListPageResValidationError) ErrorName() string { return "ListPageResValidationError" }

// Error satisfies the builtin error interface
func (e ListPageResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListPageRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListPageResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListPageResValidationError{}

// Validate checks the field values on CreateReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreateReqMultiError, or nil
// if none found.
func (m *CreateReq) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetPhone()) < 1 {
		err := CreateReqValidationError{
			field:  "Phone",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetRegisterIp()) < 1 {
		err := CreateReqValidationError{
			field:  "RegisterIp",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Name

	// no validation rules for WechatUnionId

	if m.Password != nil {
		// no validation rules for Password
	}

	if len(errors) > 0 {
		return CreateReqMultiError(errors)
	}

	return nil
}

// CreateReqMultiError is an error wrapping multiple validation errors returned
// by CreateReq.ValidateAll() if the designated constraints aren't met.
type CreateReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateReqMultiError) AllErrors() []error { return m }

// CreateReqValidationError is the validation error returned by
// CreateReq.Validate if the designated constraints aren't met.
type CreateReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateReqValidationError) ErrorName() string { return "CreateReqValidationError" }

// Error satisfies the builtin error interface
func (e CreateReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateReqValidationError{}

// Validate checks the field values on CreateRes with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateRes with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreateResMultiError, or nil
// if none found.
func (m *CreateRes) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	if len(errors) > 0 {
		return CreateResMultiError(errors)
	}

	return nil
}

// CreateResMultiError is an error wrapping multiple validation errors returned
// by CreateRes.ValidateAll() if the designated constraints aren't met.
type CreateResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateResMultiError) AllErrors() []error { return m }

// CreateResValidationError is the validation error returned by
// CreateRes.Validate if the designated constraints aren't met.
type CreateResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateResValidationError) ErrorName() string { return "CreateResValidationError" }

// Error satisfies the builtin error interface
func (e CreateResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateResValidationError{}

// Validate checks the field values on UpdateReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UpdateReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UpdateReqMultiError, or nil
// if none found.
func (m *UpdateReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUid() <= 0 {
		err := UpdateReqValidationError{
			field:  "Uid",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Password != nil {
		// no validation rules for Password
	}

	if m.Nickname != nil {
		// no validation rules for Nickname
	}

	if m.Avatar != nil {
		// no validation rules for Avatar
	}

	if m.LastLoginIp != nil {
		// no validation rules for LastLoginIp
	}

	if m.LastLoginTime != nil {
		// no validation rules for LastLoginTime
	}

	if m.Name != nil {
		// no validation rules for Name
	}

	if m.Position != nil {
		// no validation rules for Position
	}

	if m.Birthday != nil {
		// no validation rules for Birthday
	}

	if m.Sex != nil {
		// no validation rules for Sex
	}

	if m.Intro != nil {
		// no validation rules for Intro
	}

	if len(errors) > 0 {
		return UpdateReqMultiError(errors)
	}

	return nil
}

// UpdateReqMultiError is an error wrapping multiple validation errors returned
// by UpdateReq.ValidateAll() if the designated constraints aren't met.
type UpdateReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateReqMultiError) AllErrors() []error { return m }

// UpdateReqValidationError is the validation error returned by
// UpdateReq.Validate if the designated constraints aren't met.
type UpdateReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateReqValidationError) ErrorName() string { return "UpdateReqValidationError" }

// Error satisfies the builtin error interface
func (e UpdateReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateReqValidationError{}

// Validate checks the field values on UpdateRes with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UpdateRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateRes with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UpdateResMultiError, or nil
// if none found.
func (m *UpdateRes) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UpdateResMultiError(errors)
	}

	return nil
}

// UpdateResMultiError is an error wrapping multiple validation errors returned
// by UpdateRes.ValidateAll() if the designated constraints aren't met.
type UpdateResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateResMultiError) AllErrors() []error { return m }

// UpdateResValidationError is the validation error returned by
// UpdateRes.Validate if the designated constraints aren't met.
type UpdateResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateResValidationError) ErrorName() string { return "UpdateResValidationError" }

// Error satisfies the builtin error interface
func (e UpdateResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateResValidationError{}

// Validate checks the field values on UpdatePhoneReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UpdatePhoneReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdatePhoneReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UpdatePhoneReqMultiError,
// or nil if none found.
func (m *UpdatePhoneReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdatePhoneReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUid() <= 0 {
		err := UpdatePhoneReqValidationError{
			field:  "Uid",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPhone()) < 1 {
		err := UpdatePhoneReqValidationError{
			field:  "Phone",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UpdatePhoneReqMultiError(errors)
	}

	return nil
}

// UpdatePhoneReqMultiError is an error wrapping multiple validation errors
// returned by UpdatePhoneReq.ValidateAll() if the designated constraints
// aren't met.
type UpdatePhoneReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatePhoneReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatePhoneReqMultiError) AllErrors() []error { return m }

// UpdatePhoneReqValidationError is the validation error returned by
// UpdatePhoneReq.Validate if the designated constraints aren't met.
type UpdatePhoneReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatePhoneReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatePhoneReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatePhoneReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatePhoneReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatePhoneReqValidationError) ErrorName() string { return "UpdatePhoneReqValidationError" }

// Error satisfies the builtin error interface
func (e UpdatePhoneReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatePhoneReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatePhoneReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatePhoneReqValidationError{}

// Validate checks the field values on UpdatePhoneRes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UpdatePhoneRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdatePhoneRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UpdatePhoneResMultiError,
// or nil if none found.
func (m *UpdatePhoneRes) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdatePhoneRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UpdatePhoneResMultiError(errors)
	}

	return nil
}

// UpdatePhoneResMultiError is an error wrapping multiple validation errors
// returned by UpdatePhoneRes.ValidateAll() if the designated constraints
// aren't met.
type UpdatePhoneResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatePhoneResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatePhoneResMultiError) AllErrors() []error { return m }

// UpdatePhoneResValidationError is the validation error returned by
// UpdatePhoneRes.Validate if the designated constraints aren't met.
type UpdatePhoneResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatePhoneResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatePhoneResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatePhoneResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatePhoneResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatePhoneResValidationError) ErrorName() string { return "UpdatePhoneResValidationError" }

// Error satisfies the builtin error interface
func (e UpdatePhoneResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatePhoneRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatePhoneResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatePhoneResValidationError{}

// Validate checks the field values on UpdateEmailReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UpdateEmailReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateEmailReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UpdateEmailReqMultiError,
// or nil if none found.
func (m *UpdateEmailReq) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateEmailReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUid() <= 0 {
		err := UpdateEmailReqValidationError{
			field:  "Uid",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetEmail()) < 1 {
		err := UpdateEmailReqValidationError{
			field:  "Email",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UpdateEmailReqMultiError(errors)
	}

	return nil
}

// UpdateEmailReqMultiError is an error wrapping multiple validation errors
// returned by UpdateEmailReq.ValidateAll() if the designated constraints
// aren't met.
type UpdateEmailReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateEmailReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateEmailReqMultiError) AllErrors() []error { return m }

// UpdateEmailReqValidationError is the validation error returned by
// UpdateEmailReq.Validate if the designated constraints aren't met.
type UpdateEmailReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateEmailReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateEmailReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateEmailReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateEmailReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateEmailReqValidationError) ErrorName() string { return "UpdateEmailReqValidationError" }

// Error satisfies the builtin error interface
func (e UpdateEmailReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateEmailReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateEmailReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateEmailReqValidationError{}

// Validate checks the field values on UpdateEmailRes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UpdateEmailRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateEmailRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UpdateEmailResMultiError,
// or nil if none found.
func (m *UpdateEmailRes) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateEmailRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UpdateEmailResMultiError(errors)
	}

	return nil
}

// UpdateEmailResMultiError is an error wrapping multiple validation errors
// returned by UpdateEmailRes.ValidateAll() if the designated constraints
// aren't met.
type UpdateEmailResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateEmailResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateEmailResMultiError) AllErrors() []error { return m }

// UpdateEmailResValidationError is the validation error returned by
// UpdateEmailRes.Validate if the designated constraints aren't met.
type UpdateEmailResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateEmailResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateEmailResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateEmailResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateEmailResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateEmailResValidationError) ErrorName() string { return "UpdateEmailResValidationError" }

// Error satisfies the builtin error interface
func (e UpdateEmailResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateEmailRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateEmailResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateEmailResValidationError{}

// Validate checks the field values on ListReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListReq with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ListReqMultiError, or nil if none found.
func (m *ListReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ListReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetUidList()) < 1 {
		err := ListReqValidationError{
			field:  "UidList",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListReqMultiError(errors)
	}

	return nil
}

// ListReqMultiError is an error wrapping multiple validation errors returned
// by ListReq.ValidateAll() if the designated constraints aren't met.
type ListReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListReqMultiError) AllErrors() []error { return m }

// ListReqValidationError is the validation error returned by ListReq.Validate
// if the designated constraints aren't met.
type ListReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListReqValidationError) ErrorName() string { return "ListReqValidationError" }

// Error satisfies the builtin error interface
func (e ListReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListReqValidationError{}

// Validate checks the field values on ListRes with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRes with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ListResMultiError, or nil if none found.
func (m *ListRes) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetUserList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListResValidationError{
						field:  fmt.Sprintf("UserList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListResValidationError{
						field:  fmt.Sprintf("UserList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListResValidationError{
					field:  fmt.Sprintf("UserList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListResMultiError(errors)
	}

	return nil
}

// ListResMultiError is an error wrapping multiple validation errors returned
// by ListRes.ValidateAll() if the designated constraints aren't met.
type ListResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListResMultiError) AllErrors() []error { return m }

// ListResValidationError is the validation error returned by ListRes.Validate
// if the designated constraints aren't met.
type ListResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListResValidationError) ErrorName() string { return "ListResValidationError" }

// Error satisfies the builtin error interface
func (e ListResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListResValidationError{}

// Validate checks the field values on MapReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MapReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MapReq with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in MapReqMultiError, or nil if none found.
func (m *MapReq) ValidateAll() error {
	return m.validate(true)
}

func (m *MapReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetUidList()) < 1 {
		err := MapReqValidationError{
			field:  "UidList",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return MapReqMultiError(errors)
	}

	return nil
}

// MapReqMultiError is an error wrapping multiple validation errors returned by
// MapReq.ValidateAll() if the designated constraints aren't met.
type MapReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MapReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MapReqMultiError) AllErrors() []error { return m }

// MapReqValidationError is the validation error returned by MapReq.Validate if
// the designated constraints aren't met.
type MapReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MapReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MapReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MapReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MapReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MapReqValidationError) ErrorName() string { return "MapReqValidationError" }

// Error satisfies the builtin error interface
func (e MapReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMapReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MapReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MapReqValidationError{}

// Validate checks the field values on MapRes with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MapRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MapRes with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in MapResMultiError, or nil if none found.
func (m *MapRes) ValidateAll() error {
	return m.validate(true)
}

func (m *MapRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]int64, len(m.GetUserMap()))
		i := 0
		for key := range m.GetUserMap() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetUserMap()[key]
			_ = val

			// no validation rules for UserMap[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, MapResValidationError{
							field:  fmt.Sprintf("UserMap[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, MapResValidationError{
							field:  fmt.Sprintf("UserMap[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return MapResValidationError{
						field:  fmt.Sprintf("UserMap[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return MapResMultiError(errors)
	}

	return nil
}

// MapResMultiError is an error wrapping multiple validation errors returned by
// MapRes.ValidateAll() if the designated constraints aren't met.
type MapResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MapResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MapResMultiError) AllErrors() []error { return m }

// MapResValidationError is the validation error returned by MapRes.Validate if
// the designated constraints aren't met.
type MapResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MapResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MapResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MapResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MapResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MapResValidationError) ErrorName() string { return "MapResValidationError" }

// Error satisfies the builtin error interface
func (e MapResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMapRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MapResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MapResValidationError{}

// Validate checks the field values on InfoByPhoneReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *InfoByPhoneReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InfoByPhoneReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InfoByPhoneReqMultiError,
// or nil if none found.
func (m *InfoByPhoneReq) ValidateAll() error {
	return m.validate(true)
}

func (m *InfoByPhoneReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetPhone()) < 1 {
		err := InfoByPhoneReqValidationError{
			field:  "Phone",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return InfoByPhoneReqMultiError(errors)
	}

	return nil
}

// InfoByPhoneReqMultiError is an error wrapping multiple validation errors
// returned by InfoByPhoneReq.ValidateAll() if the designated constraints
// aren't met.
type InfoByPhoneReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InfoByPhoneReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InfoByPhoneReqMultiError) AllErrors() []error { return m }

// InfoByPhoneReqValidationError is the validation error returned by
// InfoByPhoneReq.Validate if the designated constraints aren't met.
type InfoByPhoneReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InfoByPhoneReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InfoByPhoneReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InfoByPhoneReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InfoByPhoneReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InfoByPhoneReqValidationError) ErrorName() string { return "InfoByPhoneReqValidationError" }

// Error satisfies the builtin error interface
func (e InfoByPhoneReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInfoByPhoneReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InfoByPhoneReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InfoByPhoneReqValidationError{}

// Validate checks the field values on LoginInfoReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LoginInfoReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginInfoReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoginInfoReqMultiError, or
// nil if none found.
func (m *LoginInfoReq) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginInfoReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUid() <= 0 {
		err := LoginInfoReqValidationError{
			field:  "Uid",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return LoginInfoReqMultiError(errors)
	}

	return nil
}

// LoginInfoReqMultiError is an error wrapping multiple validation errors
// returned by LoginInfoReq.ValidateAll() if the designated constraints aren't met.
type LoginInfoReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginInfoReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginInfoReqMultiError) AllErrors() []error { return m }

// LoginInfoReqValidationError is the validation error returned by
// LoginInfoReq.Validate if the designated constraints aren't met.
type LoginInfoReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginInfoReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginInfoReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginInfoReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginInfoReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginInfoReqValidationError) ErrorName() string { return "LoginInfoReqValidationError" }

// Error satisfies the builtin error interface
func (e LoginInfoReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginInfoReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginInfoReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginInfoReqValidationError{}

// Validate checks the field values on LoginInfoByPhoneReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LoginInfoByPhoneReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginInfoByPhoneReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LoginInfoByPhoneReqMultiError, or nil if none found.
func (m *LoginInfoByPhoneReq) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginInfoByPhoneReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetPhone()) < 1 {
		err := LoginInfoByPhoneReqValidationError{
			field:  "Phone",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return LoginInfoByPhoneReqMultiError(errors)
	}

	return nil
}

// LoginInfoByPhoneReqMultiError is an error wrapping multiple validation
// errors returned by LoginInfoByPhoneReq.ValidateAll() if the designated
// constraints aren't met.
type LoginInfoByPhoneReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginInfoByPhoneReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginInfoByPhoneReqMultiError) AllErrors() []error { return m }

// LoginInfoByPhoneReqValidationError is the validation error returned by
// LoginInfoByPhoneReq.Validate if the designated constraints aren't met.
type LoginInfoByPhoneReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginInfoByPhoneReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginInfoByPhoneReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginInfoByPhoneReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginInfoByPhoneReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginInfoByPhoneReqValidationError) ErrorName() string {
	return "LoginInfoByPhoneReqValidationError"
}

// Error satisfies the builtin error interface
func (e LoginInfoByPhoneReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginInfoByPhoneReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginInfoByPhoneReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginInfoByPhoneReqValidationError{}

// Validate checks the field values on LoginInfoRes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LoginInfoRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginInfoRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoginInfoResMultiError, or
// nil if none found.
func (m *LoginInfoRes) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginInfoRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	// no validation rules for Password

	// no validation rules for Nickname

	// no validation rules for Avatar

	// no validation rules for Name

	// no validation rules for GocnPassword

	if len(errors) > 0 {
		return LoginInfoResMultiError(errors)
	}

	return nil
}

// LoginInfoResMultiError is an error wrapping multiple validation errors
// returned by LoginInfoRes.ValidateAll() if the designated constraints aren't met.
type LoginInfoResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginInfoResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginInfoResMultiError) AllErrors() []error { return m }

// LoginInfoResValidationError is the validation error returned by
// LoginInfoRes.Validate if the designated constraints aren't met.
type LoginInfoResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginInfoResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginInfoResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginInfoResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginInfoResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginInfoResValidationError) ErrorName() string { return "LoginInfoResValidationError" }

// Error satisfies the builtin error interface
func (e LoginInfoResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginInfoRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginInfoResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginInfoResValidationError{}

// Validate checks the field values on LoginInfoByPhoneRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LoginInfoByPhoneRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginInfoByPhoneRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LoginInfoByPhoneResMultiError, or nil if none found.
func (m *LoginInfoByPhoneRes) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginInfoByPhoneRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoginInfoByPhoneResValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoginInfoByPhoneResValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoginInfoByPhoneResValidationError{
				field:  "User",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LoginInfoByPhoneResMultiError(errors)
	}

	return nil
}

// LoginInfoByPhoneResMultiError is an error wrapping multiple validation
// errors returned by LoginInfoByPhoneRes.ValidateAll() if the designated
// constraints aren't met.
type LoginInfoByPhoneResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginInfoByPhoneResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginInfoByPhoneResMultiError) AllErrors() []error { return m }

// LoginInfoByPhoneResValidationError is the validation error returned by
// LoginInfoByPhoneRes.Validate if the designated constraints aren't met.
type LoginInfoByPhoneResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginInfoByPhoneResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginInfoByPhoneResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginInfoByPhoneResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginInfoByPhoneResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginInfoByPhoneResValidationError) ErrorName() string {
	return "LoginInfoByPhoneResValidationError"
}

// Error satisfies the builtin error interface
func (e LoginInfoByPhoneResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginInfoByPhoneRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginInfoByPhoneResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginInfoByPhoneResValidationError{}

// Validate checks the field values on LoginInfoByNameReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LoginInfoByNameReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginInfoByNameReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LoginInfoByNameReqMultiError, or nil if none found.
func (m *LoginInfoByNameReq) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginInfoByNameReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := LoginInfoByNameReqValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return LoginInfoByNameReqMultiError(errors)
	}

	return nil
}

// LoginInfoByNameReqMultiError is an error wrapping multiple validation errors
// returned by LoginInfoByNameReq.ValidateAll() if the designated constraints
// aren't met.
type LoginInfoByNameReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginInfoByNameReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginInfoByNameReqMultiError) AllErrors() []error { return m }

// LoginInfoByNameReqValidationError is the validation error returned by
// LoginInfoByNameReq.Validate if the designated constraints aren't met.
type LoginInfoByNameReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginInfoByNameReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginInfoByNameReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginInfoByNameReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginInfoByNameReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginInfoByNameReqValidationError) ErrorName() string {
	return "LoginInfoByNameReqValidationError"
}

// Error satisfies the builtin error interface
func (e LoginInfoByNameReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginInfoByNameReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginInfoByNameReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginInfoByNameReqValidationError{}

// Validate checks the field values on LoginInfoByNameRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LoginInfoByNameRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginInfoByNameRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LoginInfoByNameResMultiError, or nil if none found.
func (m *LoginInfoByNameRes) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginInfoByNameRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoginInfoByNameResValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoginInfoByNameResValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoginInfoByNameResValidationError{
				field:  "User",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LoginInfoByNameResMultiError(errors)
	}

	return nil
}

// LoginInfoByNameResMultiError is an error wrapping multiple validation errors
// returned by LoginInfoByNameRes.ValidateAll() if the designated constraints
// aren't met.
type LoginInfoByNameResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginInfoByNameResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginInfoByNameResMultiError) AllErrors() []error { return m }

// LoginInfoByNameResValidationError is the validation error returned by
// LoginInfoByNameRes.Validate if the designated constraints aren't met.
type LoginInfoByNameResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginInfoByNameResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginInfoByNameResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginInfoByNameResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginInfoByNameResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginInfoByNameResValidationError) ErrorName() string {
	return "LoginInfoByNameResValidationError"
}

// Error satisfies the builtin error interface
func (e LoginInfoByNameResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginInfoByNameRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginInfoByNameResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginInfoByNameResValidationError{}

// Validate checks the field values on InfoReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *InfoReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InfoReq with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in InfoReqMultiError, or nil if none found.
func (m *InfoReq) ValidateAll() error {
	return m.validate(true)
}

func (m *InfoReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	// no validation rules for Name

	if len(errors) > 0 {
		return InfoReqMultiError(errors)
	}

	return nil
}

// InfoReqMultiError is an error wrapping multiple validation errors returned
// by InfoReq.ValidateAll() if the designated constraints aren't met.
type InfoReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InfoReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InfoReqMultiError) AllErrors() []error { return m }

// InfoReqValidationError is the validation error returned by InfoReq.Validate
// if the designated constraints aren't met.
type InfoReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InfoReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InfoReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InfoReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InfoReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InfoReqValidationError) ErrorName() string { return "InfoReqValidationError" }

// Error satisfies the builtin error interface
func (e InfoReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInfoReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InfoReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InfoReqValidationError{}

// Validate checks the field values on UserInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserInfoMultiError, or nil
// if none found.
func (m *UserInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *UserInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Nickname

	// no validation rules for Email

	// no validation rules for Avatar

	// no validation rules for Uid

	// no validation rules for Identify

	// no validation rules for Name

	// no validation rules for Position

	// no validation rules for ActiveTime

	// no validation rules for Password

	// no validation rules for Status

	// no validation rules for GocnPassword

	if len(errors) > 0 {
		return UserInfoMultiError(errors)
	}

	return nil
}

// UserInfoMultiError is an error wrapping multiple validation errors returned
// by UserInfo.ValidateAll() if the designated constraints aren't met.
type UserInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserInfoMultiError) AllErrors() []error { return m }

// UserInfoValidationError is the validation error returned by
// UserInfo.Validate if the designated constraints aren't met.
type UserInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserInfoValidationError) ErrorName() string { return "UserInfoValidationError" }

// Error satisfies the builtin error interface
func (e UserInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserInfoValidationError{}

// Validate checks the field values on InfoRes with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *InfoRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InfoRes with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in InfoResMultiError, or nil if none found.
func (m *InfoRes) ValidateAll() error {
	return m.validate(true)
}

func (m *InfoRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InfoResValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InfoResValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InfoResValidationError{
				field:  "User",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InfoResMultiError(errors)
	}

	return nil
}

// InfoResMultiError is an error wrapping multiple validation errors returned
// by InfoRes.ValidateAll() if the designated constraints aren't met.
type InfoResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InfoResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InfoResMultiError) AllErrors() []error { return m }

// InfoResValidationError is the validation error returned by InfoRes.Validate
// if the designated constraints aren't met.
type InfoResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InfoResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InfoResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InfoResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InfoResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InfoResValidationError) ErrorName() string { return "InfoResValidationError" }

// Error satisfies the builtin error interface
func (e InfoResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInfoRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InfoResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InfoResValidationError{}

// Validate checks the field values on InfoByPhoneRes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *InfoByPhoneRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InfoByPhoneRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InfoByPhoneResMultiError,
// or nil if none found.
func (m *InfoByPhoneRes) ValidateAll() error {
	return m.validate(true)
}

func (m *InfoByPhoneRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InfoByPhoneResValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InfoByPhoneResValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InfoByPhoneResValidationError{
				field:  "User",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InfoByPhoneResMultiError(errors)
	}

	return nil
}

// InfoByPhoneResMultiError is an error wrapping multiple validation errors
// returned by InfoByPhoneRes.ValidateAll() if the designated constraints
// aren't met.
type InfoByPhoneResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InfoByPhoneResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InfoByPhoneResMultiError) AllErrors() []error { return m }

// InfoByPhoneResValidationError is the validation error returned by
// InfoByPhoneRes.Validate if the designated constraints aren't met.
type InfoByPhoneResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InfoByPhoneResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InfoByPhoneResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InfoByPhoneResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InfoByPhoneResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InfoByPhoneResValidationError) ErrorName() string { return "InfoByPhoneResValidationError" }

// Error satisfies the builtin error interface
func (e InfoByPhoneResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInfoByPhoneRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InfoByPhoneResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InfoByPhoneResValidationError{}

// Validate checks the field values on OauthInfoReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OauthInfoReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OauthInfoReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OauthInfoReqMultiError, or
// nil if none found.
func (m *OauthInfoReq) ValidateAll() error {
	return m.validate(true)
}

func (m *OauthInfoReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetUid() <= 0 {
		err := OauthInfoReqValidationError{
			field:  "Uid",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return OauthInfoReqMultiError(errors)
	}

	return nil
}

// OauthInfoReqMultiError is an error wrapping multiple validation errors
// returned by OauthInfoReq.ValidateAll() if the designated constraints aren't met.
type OauthInfoReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OauthInfoReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OauthInfoReqMultiError) AllErrors() []error { return m }

// OauthInfoReqValidationError is the validation error returned by
// OauthInfoReq.Validate if the designated constraints aren't met.
type OauthInfoReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OauthInfoReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OauthInfoReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OauthInfoReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OauthInfoReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OauthInfoReqValidationError) ErrorName() string { return "OauthInfoReqValidationError" }

// Error satisfies the builtin error interface
func (e OauthInfoReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOauthInfoReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OauthInfoReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OauthInfoReqValidationError{}

// Validate checks the field values on OauthInfoRes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OauthInfoRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OauthInfoRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OauthInfoResMultiError, or
// nil if none found.
func (m *OauthInfoRes) ValidateAll() error {
	return m.validate(true)
}

func (m *OauthInfoRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Nickname

	// no validation rules for Email

	// no validation rules for Avatar

	// no validation rules for Identify

	// no validation rules for Name

	// no validation rules for CmtIdentifyStatus

	// no validation rules for ApplyMaxCmtCnt

	if len(errors) > 0 {
		return OauthInfoResMultiError(errors)
	}

	return nil
}

// OauthInfoResMultiError is an error wrapping multiple validation errors
// returned by OauthInfoRes.ValidateAll() if the designated constraints aren't met.
type OauthInfoResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OauthInfoResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OauthInfoResMultiError) AllErrors() []error { return m }

// OauthInfoResValidationError is the validation error returned by
// OauthInfoRes.Validate if the designated constraints aren't met.
type OauthInfoResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OauthInfoResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OauthInfoResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OauthInfoResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OauthInfoResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OauthInfoResValidationError) ErrorName() string { return "OauthInfoResValidationError" }

// Error satisfies the builtin error interface
func (e OauthInfoResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOauthInfoRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OauthInfoResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OauthInfoResValidationError{}

// Validate checks the field values on ProfileInfoReq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ProfileInfoReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProfileInfoReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ProfileInfoReqMultiError,
// or nil if none found.
func (m *ProfileInfoReq) ValidateAll() error {
	return m.validate(true)
}

func (m *ProfileInfoReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	// no validation rules for Name

	if len(errors) > 0 {
		return ProfileInfoReqMultiError(errors)
	}

	return nil
}

// ProfileInfoReqMultiError is an error wrapping multiple validation errors
// returned by ProfileInfoReq.ValidateAll() if the designated constraints
// aren't met.
type ProfileInfoReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProfileInfoReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProfileInfoReqMultiError) AllErrors() []error { return m }

// ProfileInfoReqValidationError is the validation error returned by
// ProfileInfoReq.Validate if the designated constraints aren't met.
type ProfileInfoReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProfileInfoReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProfileInfoReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProfileInfoReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProfileInfoReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProfileInfoReqValidationError) ErrorName() string { return "ProfileInfoReqValidationError" }

// Error satisfies the builtin error interface
func (e ProfileInfoReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProfileInfoReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProfileInfoReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProfileInfoReqValidationError{}

// Validate checks the field values on ProfileInfoRes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ProfileInfoRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProfileInfoRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ProfileInfoResMultiError,
// or nil if none found.
func (m *ProfileInfoRes) ValidateAll() error {
	return m.validate(true)
}

func (m *ProfileInfoRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	// no validation rules for Nickname

	// no validation rules for Email

	// no validation rules for Avatar

	// no validation rules for IdentifyStatus

	// no validation rules for Intro

	// no validation rules for Sex

	// no validation rules for Birthday

	// no validation rules for Name

	// no validation rules for RegisterTime

	if len(errors) > 0 {
		return ProfileInfoResMultiError(errors)
	}

	return nil
}

// ProfileInfoResMultiError is an error wrapping multiple validation errors
// returned by ProfileInfoRes.ValidateAll() if the designated constraints
// aren't met.
type ProfileInfoResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProfileInfoResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProfileInfoResMultiError) AllErrors() []error { return m }

// ProfileInfoResValidationError is the validation error returned by
// ProfileInfoRes.Validate if the designated constraints aren't met.
type ProfileInfoResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProfileInfoResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProfileInfoResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProfileInfoResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProfileInfoResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProfileInfoResValidationError) ErrorName() string { return "ProfileInfoResValidationError" }

// Error satisfies the builtin error interface
func (e ProfileInfoResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProfileInfoRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProfileInfoResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProfileInfoResValidationError{}

// Validate checks the field values on LoginUserOpenReq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *LoginUserOpenReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginUserOpenReq with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LoginUserOpenReqMultiError, or nil if none found.
func (m *LoginUserOpenReq) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginUserOpenReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Genre

	// no validation rules for OpenId

	// no validation rules for UnionId

	// no validation rules for Nickname

	// no validation rules for Avatar

	// no validation rules for Sex

	// no validation rules for Country

	// no validation rules for Province

	// no validation rules for City

	// no validation rules for Telephone

	if len(errors) > 0 {
		return LoginUserOpenReqMultiError(errors)
	}

	return nil
}

// LoginUserOpenReqMultiError is an error wrapping multiple validation errors
// returned by LoginUserOpenReq.ValidateAll() if the designated constraints
// aren't met.
type LoginUserOpenReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginUserOpenReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginUserOpenReqMultiError) AllErrors() []error { return m }

// LoginUserOpenReqValidationError is the validation error returned by
// LoginUserOpenReq.Validate if the designated constraints aren't met.
type LoginUserOpenReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginUserOpenReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginUserOpenReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginUserOpenReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginUserOpenReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginUserOpenReqValidationError) ErrorName() string { return "LoginUserOpenReqValidationError" }

// Error satisfies the builtin error interface
func (e LoginUserOpenReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginUserOpenReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginUserOpenReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginUserOpenReqValidationError{}

// Validate checks the field values on LoginUserOpenRes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *LoginUserOpenRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginUserOpenRes with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LoginUserOpenResMultiError, or nil if none found.
func (m *LoginUserOpenRes) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginUserOpenRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Uid

	// no validation rules for Nickname

	// no validation rules for Avatar

	// no validation rules for Phone

	if len(errors) > 0 {
		return LoginUserOpenResMultiError(errors)
	}

	return nil
}

// LoginUserOpenResMultiError is an error wrapping multiple validation errors
// returned by LoginUserOpenRes.ValidateAll() if the designated constraints
// aren't met.
type LoginUserOpenResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginUserOpenResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginUserOpenResMultiError) AllErrors() []error { return m }

// LoginUserOpenResValidationError is the validation error returned by
// LoginUserOpenRes.Validate if the designated constraints aren't met.
type LoginUserOpenResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginUserOpenResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginUserOpenResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginUserOpenResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginUserOpenResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginUserOpenResValidationError) ErrorName() string { return "LoginUserOpenResValidationError" }

// Error satisfies the builtin error interface
func (e LoginUserOpenResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginUserOpenRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginUserOpenResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginUserOpenResValidationError{}

// Validate checks the field values on SearchReq with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SearchReq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SearchReq with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SearchReqMultiError, or nil
// if none found.
func (m *SearchReq) ValidateAll() error {
	return m.validate(true)
}

func (m *SearchReq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Nickname

	if len(errors) > 0 {
		return SearchReqMultiError(errors)
	}

	return nil
}

// SearchReqMultiError is an error wrapping multiple validation errors returned
// by SearchReq.ValidateAll() if the designated constraints aren't met.
type SearchReqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SearchReqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SearchReqMultiError) AllErrors() []error { return m }

// SearchReqValidationError is the validation error returned by
// SearchReq.Validate if the designated constraints aren't met.
type SearchReqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SearchReqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SearchReqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SearchReqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SearchReqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SearchReqValidationError) ErrorName() string { return "SearchReqValidationError" }

// Error satisfies the builtin error interface
func (e SearchReqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSearchReq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SearchReqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SearchReqValidationError{}

// Validate checks the field values on SearchRes with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SearchRes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SearchRes with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SearchResMultiError, or nil
// if none found.
func (m *SearchRes) ValidateAll() error {
	return m.validate(true)
}

func (m *SearchRes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SearchResValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SearchResValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SearchResValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SearchResMultiError(errors)
	}

	return nil
}

// SearchResMultiError is an error wrapping multiple validation errors returned
// by SearchRes.ValidateAll() if the designated constraints aren't met.
type SearchResMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SearchResMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SearchResMultiError) AllErrors() []error { return m }

// SearchResValidationError is the validation error returned by
// SearchRes.Validate if the designated constraints aren't met.
type SearchResValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SearchResValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SearchResValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SearchResValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SearchResValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SearchResValidationError) ErrorName() string { return "SearchResValidationError" }

// Error satisfies the builtin error interface
func (e SearchResValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSearchRes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SearchResValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SearchResValidationError{}
